## select contigs > 500 bp and at least 10% coverage of the largest genome
## blast all contigs and select the species level and plot 

import argparse
import os, subprocess
from Bio import SeqIO
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib.lines import Line2D
import seaborn as sns
import pandas as pd


## inputs which need to be provided via argparse
''' positional and optional argument parser'''

parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                description='''\
                                Script to remove short and low coverage contigs from de novo assemblies generated by SPAdes.
                                Trigger blast run for all contigs on a subset of the sequence (extracted from the center of the contig)
                                and generate pidentity difference between target species and top blast hit for removed vs retained contigs.
                                ''')
parser.add_argument("-i", dest='infasta', help="Input fasta file generated by SPAdes.", type=str)
#parser.add_argument("-o", dest='outfasta', help="Output fasta file with path.", type=str)
parser.add_argument("-o", dest='outdir', help="Output path to save all results in.", type=str)
parser.add_argument("-db", dest='ncbi_db', help="Path to NCBI nt database.", type=str)
parser.add_argument("-cl", dest='contig_len', help="Minimum length to keep a contig. [default = 500]", type=int, default = 500)
parser.add_argument("-cc", dest='contig_cov', 
                    help="Percentage of coverage from largest contig to keep a contig.\n I.e. 0.1 would keep contigs whcih have at least 10%% of the coverage of the largest contig. [default = 0.1]", 
                    type=float, default = 0.1)
parser.add_argument("-l", dest='blast_len', help="Sequence length to blast. [default = 1000]", type=int, default = 1000)
parser.add_argument('-t', dest='threads',help="Number of threads. [default = 1]",type=int,default=1)
parser.add_argument('-b', dest='do_blast',help="Run Blast on all contigs and plot p identity difference to top non-target species hit per contig.",action="store_true")
args = parser.parse_args()


''' FUNCTIONS'''

## remove low coverage and short contigs from fasta
def clean_fasta(infasta, outfasta, out_rem_fasta, min_contig_len = 500, rel_contig_cov = 0.1):
    fasta_out = open(outfasta, 'w')
    fasta_del_out = open(out_rem_fasta, 'w')

    for i, record in enumerate(SeqIO.parse(infasta, "fasta")):
        seq_len = int(record.description.split('_')[3])
        seq_cov = float(record.description.split('_')[5])

        if i == 0: ## extract coverage cutoff from largest sequence
            cov_cutoff = seq_cov * rel_contig_cov

        ## keep sequence if larger than min_len and assembly specific cov_cutoff
        if (seq_len >= min_contig_len) & (seq_cov >= cov_cutoff):
            fasta_out.write(">%s\n%s\n" % (record.description, record.seq))
        elif (seq_len >= min_contig_len) & (seq_cov < cov_cutoff): ## save for blast all which are long but have low coverage! 
            fasta_del_out.write(">%s\n%s\n" % (record.description, record.seq))

## recieve n bases at the middle of the contig, if contig is smaller, take entire contig
def subset_fasta(infasta, outdir, seq_len_subset = 1000):
    out_filename = infasta.split('/')[-1]
    outfasta_blast = outdir + os.path.splitext(out_filename)[0] + '_' + str(seq_len_subset) + 'bp.fasta'
    ## get half final sequence length to center on contig
    seq_len_subset = int(seq_len_subset / 2)
    with open(outfasta_blast, 'w') as fo:
        ## extract sequence per contig
        for record in SeqIO.parse(infasta, "fasta"):
            seq_len = len(record.seq)
            start_seq = int(seq_len / 2) - seq_len_subset
            end_seq = int(seq_len / 2) + seq_len_subset
            if start_seq < 0: ## if one slice is out of bounds, than both are!
                start_seq = 0
                end_seq = seq_len
            fo.write(">%s\n%s\n" % (record.description, record.seq[start_seq:end_seq]))
    return outfasta_blast

## trigger blast run
def run_blast(fasta, blast_db, threads = 2):
    blast_out = fasta.replace('/blast/seqs/', '/blast/results/').replace('.fasta', '.out')
    if os.stat(fasta).st_size > 0:
        # blast_fmt = '6 qacc qlen staxids sacc stitle slen qstart qend sstart send length evalue bitscore pident'
        blast_fmt = '6 qacc qlen sacc stitle slen qstart qend sstart send length evalue bitscore pident'
        print('\nRunning the following blast statement:')
        print(f'blastn -db {blast_db} -query {fasta} -out {blast_out} -outfmt "{blast_fmt}" -num_threads {threads} -max_target_seqs 20\n')
        subprocess.run(f'blastn -db {blast_db} -query {fasta} -out {blast_out} -outfmt "{blast_fmt}" -num_threads {threads} -max_target_seqs 20', shell=True)
    
    return blast_out 

def read_blast_results(blast_res, spec_mapper = ''): ## spec_mapper should be df to map species abbreviation to full species names
    blast_res_df = pd.DataFrame()
    genome = blast_res.split('/')[-4] ## genome name is before [/blast/results/blast.out]
    # genome = 'subject_P21_Pmirabilis'
    try: 
        blast_res_df = pd.read_csv(blast_res, sep = '\t', header = None)
        # blast_res_df.columns = ['contig_id', 'blast_len', 'taxid', 'acc_id', 'acc_name', 'accontig_length', 'contigstart', 'contigend', 'accstart', 'accend', 'acc_aln_length', 'eval', 'bitscore', 'identity']
        blast_res_df.columns = ['contig_id', 'blast_len', 'acc_id', 'acc_name', 'accontig_length', 'contigstart', 'contigend', 'accstart', 'accend', 'acc_aln_length', 'eval', 'bitscore', 'identity']
        blast_res_df['genome_assembly'] = genome
        blast_res_df['contig_id_num'] = blast_res_df['contig_id'].str.split('_').str[1].astype(int)
        blast_res_df['contig_len'] = blast_res_df['contig_id'].str.split('_').str[3].astype(int)
        blast_res_df = blast_res_df[['genome_assembly', 'contig_id', 'contig_id_num', 'contig_len', 'blast_len', 'acc_id', 'acc_name', 'contigstart', 'contigend', 'accstart', 'accend', 'eval', 'bitscore', 'identity']]
        ## extract best 10 hits per contig
        blast_res_df = blast_res_df.sort_values(['bitscore', 'eval', 'identity'], ascending = [False, True, False]) ## sort values by bitscore as the values reported are clustered by acc_id and within those groups sorted by bitscore and eval!
        ## remove all entries with poor evalues 
        blast_res_df = blast_res_df[blast_res_df['eval'] < 0.05]
        blast_res_df.reset_index(drop = True, inplace = True)
        ## extract the species name of the accession name field
        blast_res_df['acc_species'] = blast_res_df['acc_name'].str.split(' ').str[:2].str.join(' ')
        blast_res_df['genome'] = blast_res_df['genome_assembly'].str.split('_').str[2] ## just get the genome names without extensions ## note there it would be nice to use taxids mapping instead!
    except:
        blast_res_df = pd.DataFrame()
        print(f'Empty Blast results file: {blast_res}')
    return blast_res_df, genome

def pidentity_diff(blast_results):
    ## extract the target species' top hit
    ## convert genome tag names to species names --> this should be done via a csv file later!
    target_species_dict = {'Apittii': 'Acinetobacter pittii', 
                            'Bthetaiotaomicron': 'Bacteroides thetaiotaomicron', 
                            'Kmichiganensis': 'Klebsiella michiganensis', 
                            'Mmorganii': 'Morganella morganii',
                            'Ecoli': 'Escherichia coli', 
                            'Smaltophilia': 'Stenotrophomonas maltophilia', 
                            'Saureus': 'Staphylococcus aureus', 
                            'Ehormaechei': 'Enterobacter hormaechei', 
                            'Pmirabilis': 'Proteus mirabilis'}

    blast_results['target_species'] = blast_results['genome'].map(target_species_dict) ## overwrites the result from above which is not needed!

    ## extract target species's top hits per contig
    blast_results = blast_results.sort_values(['bitscore', 'eval', 'identity'], ascending = [False, True, False]) ## ensure that df is sorted properly!
    top_target_hit_blast = blast_results[blast_results['acc_species'] == blast_results['target_species']] ## extract entries where blast hit == expected species
    top_target_hit_blast = top_target_hit_blast.groupby(['genome', 'contig_id']).head(1) ## extract top hits per genome and contig
    top_nontarget_hit = blast_results[blast_results['acc_species'] != blast_results['target_species']] ## extract entries where blast hit == expected species
    top_nontarget_hit = top_nontarget_hit.groupby(['genome', 'contig_id']).head(1) ## extract top hits per genome and contig
    ## combine top blast hits for target and non-target 
    top_target_hit_blast['hit_id'] = 'top_target_hit'
    top_nontarget_hit['hit_id'] = 'top_nontarget_hit'

    ## calculate pidentity difference
    same_columns = ['genome', 'genome_assembly', 'contig_id', 'contig_id_num', 'contig_len', 'blast_len']
    blast_hit_diff = pd.merge(top_target_hit_blast, top_nontarget_hit, how = 'outer', on = same_columns, suffixes=['_target', '_nontarget'])
    blast_hit_diff['pident_diff'] = blast_hit_diff['identity_nontarget'] - blast_hit_diff['identity_target']
    
    blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_nontarget'].isna(), 'pident_diff'] = 0 # blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_nontarget'].isna(), 'identity_target'] ## 0 == no difference to target species
    blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_nontarget'].isna(), 'acc_species_nontarget'] = 'NA'
    blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_nontarget'].isna(), 'identity_nontarget'] = 0
    blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_target'].isna(), 'pident_diff'] = blast_hit_diff.loc[blast_hit_diff['pident_diff'].isna() & blast_hit_diff['identity_target'].isna(), 'identity_nontarget'] ## --> if no target species found, pidentity diff goes up!
    ## if target better than nontarget, pident_diff is below 0 --> set pidentity diff to 0 ( we just want to evaluate if and which scaffolds might be from other species! )
    blast_hit_diff.loc[blast_hit_diff['pident_diff'] < 0, 'pident_diff'] = 0

    return blast_hit_diff

## plot blast results as pidentity difference 
def plt_pidentity_diff(blast_results_cl_f, blast_results_rm_f, plt_file):
    
    blast_results_cl, assembly_name_cl = read_blast_results(blast_results_cl_f)
    blast_results_rm, assembly_name_rm= read_blast_results(blast_results_rm_f)
    
    row_no = 0
    ax_id_rm = 0
    max_num_contigs_cl = 0
    max_num_contigs_rm = 0

    if not blast_results_cl.empty:
        blast_results_cl = pidentity_diff(blast_results_cl)
        row_no += 1
        max_contig_len = max(blast_results_cl['contig_id'].str.split('_').str[3].astype(int))
        max_num_contigs_cl = len(blast_results_cl['contig_id_num'].unique())
        ax_id_rm = 1
        assembly_name = assembly_name_cl
    if not blast_results_rm.empty:
        blast_results_rm = pidentity_diff(blast_results_rm)
        max_num_contigs_rm = len(blast_results_rm['contig_id_num'].unique())
        row_no += 1
        if not 'assembly_name' in locals():
            assembly_name = assembly_name_rm
    if row_no == 0:
        print('\n\n\nNo blast entries to plot! Stopped script!\n\n\n')
        return

    ## get unique non-target species to keep same color scheme in plots
    try:
        all_contigs_df = pd.concat([blast_results_cl, blast_results_rm])
        all_contigs_df = all_contigs_df[~all_contigs_df['acc_species_nontarget'].isna()] ## remove na values
        unique_nt_species = all_contigs_df.sort_values('acc_species_nontarget')['acc_species_nontarget'].unique().tolist()
        unique_nt_species.append('NA')
        if not blast_results_cl.empty:
            blast_results_cl.loc[blast_results_cl['acc_species_nontarget'].isna(), 'acc_species_nontarget'] = 'NA'
            blast_results_cl['acc_species_nontarget'] = pd.Categorical(blast_results_cl['acc_species_nontarget'], unique_nt_species, ordered = True)
        if not blast_results_rm.empty:
            blast_results_rm.loc[blast_results_rm['acc_species_nontarget'].isna(), 'acc_species_nontarget'] = 'NA'
            blast_results_rm['acc_species_nontarget'] = pd.Categorical(blast_results_rm['acc_species_nontarget'], unique_nt_species, ordered = True)
    except:
        print(f'Not able to identify unique species in df. Files used:\n{blast_results_cl_f}\n{blast_results_rm_f}\nAre both files empty?')

    cmap_tab = plt.get_cmap('tab20')
    cmap_pastel = plt.get_cmap('Pastel2')
    ext_colors = [cmap_tab(rgba) if rgba <= cmap_tab.N else cmap_pastel(rgba-cmap_tab.N) for rgba in range(cmap_tab.N + cmap_pastel.N)]
    cmap_nt_spec = colors.ListedColormap(ext_colors) 
    cmap_nt_spec_l = [cmap_nt_spec(i) for i in range(len(unique_nt_species))]
    ## change nan value to grey
    cmap_nt_spec_l[-1] = (0.7, 0.7, 0.7, 0.8)

    fig, axs = plt.subplots(figsize = (12, 6 * row_no), nrows = row_no, squeeze = False)
    ax = axs.flatten()
    
    if not blast_results_cl.empty:
        sns.scatterplot(x = 'contig_len', y = 'pident_diff', hue = 'acc_species_nontarget', data = blast_results_cl, 
                        alpha = 0.8, s = 75, palette = cmap_nt_spec_l, ax = ax[0])
        ax[0].set_ylim((-5, 110))
        ax[0].set_xlim((250, max_contig_len * 3)) ## multiplication to make enough space for the annotation!
        ax[0].set_xscale('log')
        ax[0].set_ylabel('Percent identity difference\n[non-target - target species]')
        ax[0].set_xlabel('Contig length [bp]')
        ax[0].set_title('Kept contigs >= 500 bp')
        ax[0].grid(which='major', axis='y')
        ax[0].legend(title = 'Non-target species', bbox_to_anchor=(1.03, 1), loc = 'upper left')
    if not blast_results_rm.empty:
        sns.scatterplot(x = 'contig_len', y = 'pident_diff', hue = 'acc_species_nontarget', data = blast_results_rm, 
                        alpha = 0.8, s = 75, palette = cmap_nt_spec_l, ax = ax[ax_id_rm])
        ax[ax_id_rm].set_ylim((-5, 110))
        ax[ax_id_rm].set_xlim((250, max_contig_len * 3)) ## multiplication to make enough space for the annotation!
        ax[ax_id_rm].set_xscale('log')
        ax[ax_id_rm].set_ylabel('Percent identity difference\n[non-target - target species]')
        ax[ax_id_rm].set_xlabel('Contig length [bp]')
        ax[ax_id_rm].set_title('Removed contigs >= 500 bp')
        ax[ax_id_rm].grid(which='major', axis='y')
        if ax_id_rm == 1: ## first plot was plotted with the same legend --> remove legend
            ax[ax_id_rm].get_legend().remove()
        else:
            ax[ax_id_rm].legend(title = 'Non-target species', bbox_to_anchor=(1.03, 1), loc = 'upper left')

    fig.suptitle(f'Percent-identity differences of non-target vs target species\nof top Blast hits per contig in {assembly_name}', size = 14)
    plt.tight_layout()
    fig.savefig(plt_file)


    # blast_results_cl = blast_results_cl[blast_results_cl['contig_id_num']< 50]
    
    max_contig_num = max(max_num_contigs_cl, max_num_contigs_rm)
    fig_width = int(max_contig_num/7) + 1
    if fig_width < 8:
        fig_width = 8
    bbox_xshift = (fig_width+2) / fig_width
    fig, axs = plt.subplots(figsize = (fig_width, 6 * row_no), nrows = row_no, squeeze = False)
    ax = axs.flatten()

    if not blast_results_cl.empty:
        ## just plot instances where non target has better blast hits:
        blast_results_cl_nont = blast_results_cl.copy()
        blast_results_cl_nont['contig_id_num'] = pd.Categorical(blast_results_cl_nont['contig_id_num'], blast_results_cl_nont.sort_values('contig_id_num')['contig_id_num'].unique(), ordered = True) ## change to categoricals to plot all contigs
        blast_results_cl_nont = blast_results_cl_nont[blast_results_cl_nont['pident_diff'] > 0] ## subset df to instances where nontarget has better blast hit

        if not blast_results_cl_nont.empty:
            ax_2nd = ax[0].twinx()
            sns.barplot(x = 'contig_id_num', y = 'identity_nontarget', hue = 'acc_species_nontarget', data = blast_results_cl_nont, 
                            alpha = 0.8, palette = cmap_nt_spec_l, dodge=False, ax = ax[0])
            sns.stripplot(x = 'contig_id_num', y = 'pident_diff', color = 'black', data = blast_results_cl_nont, 
                            alpha = 1, s = 10, jitter = False, ax = ax_2nd)
            
            ## get legend and append p identity marker
            handles, labels = ax[0].get_legend_handles_labels()
            handles += [Line2D([], [], marker='None', linestyle='None')] ## header
            handles += [Line2D([0], [0], marker = 'o', color = 'w', markerfacecolor = 'k', label = 'p-identity difference', markersize = 10)] ## isolate counts
            labels += ['', 'p-identity difference']
            # lgd = ax[0].legend(title = 'Non-target species', handles = handles, labels = labels, bbox_to_anchor=(1.2, 1), loc = 'upper left') ## add legend when plot is saved
            ax[0].legend(title = 'Non-target species', handles = handles, labels = labels, bbox_to_anchor=(bbox_xshift, 1), loc = 'upper left')

            ax[0].set_ylim((-5, 110))
            ax_2nd.set_ylim((-5, 110))
            ax[0].set_ylabel('Percent identity [non-target species]')
            ax_2nd.set_ylabel('Percent identity difference\n[non-target - target species]')
            ax[0].set_xlabel('Contig ID')
            ax[0].set_xticklabels(ax[0].get_xticklabels(), rotation=90)
            ax[0].set_title('Kept contigs >= 500 bp')
            ax[0].grid(which='major', axis='y')
        else:
            fig.delaxes(ax[1]) ## delete second subplot as this is not needed (because the plot was empty)
            if ax_id_rm == 1: ## set plotting to the right axis!
                ax_id_rm = 0
    if not blast_results_rm.empty:
        ## just plot instances where non target has better blast hits:
        blast_results_rm_nont = blast_results_rm.copy()
        blast_results_rm_nont['contig_id_num'] = pd.Categorical(blast_results_rm_nont['contig_id_num'], blast_results_rm_nont.sort_values('contig_id_num')['contig_id_num'].unique(), ordered = True) ## change to categoricals to plot all contigs
        blast_results_rm_nont = blast_results_rm_nont[blast_results_rm_nont['pident_diff'] > 0] ## subset df to instances where nontarget has better blast hit

        if not blast_results_rm_nont.empty:
            ax_rm_2nd = ax[ax_id_rm].twinx()
            sns.barplot(x = 'contig_id_num', y = 'identity_nontarget', hue = 'acc_species_nontarget', data = blast_results_rm, 
                            alpha = 0.8, palette = cmap_nt_spec_l, dodge=False, ax = ax[ax_id_rm])
            sns.stripplot(x = 'contig_id_num', y = 'pident_diff', color = 'black', data = blast_results_rm, 
                            alpha = 1, s = 10, jitter = False, ax = ax_rm_2nd)
            
            ## get legend and append p identity marker
            handles, labels = ax[0].get_legend_handles_labels()
            handles += [Line2D([], [], marker='None', linestyle='None')] ## header
            handles += [Line2D([0], [0], marker = 'o', color = 'w', markerfacecolor = 'k', label = 'p-identity difference', markersize = 10)] ## isolate counts
            labels += ['', 'p-identity difference']
            #lgd = ax[0].legend(title = 'Non-target species', handles = handles, labels = labels, bbox_to_anchor=(1.2, 1), loc = 'upper left') ## add legend when plot is saved, note: just place legend on first subplot!
            if ax_id_rm == 1:
                ax[ax_id_rm].get_legend().remove()
            else:
                ax[0].legend(title = 'Non-target species', handles = handles, labels = labels, bbox_to_anchor=(bbox_xshift, 1), loc = 'upper left')
            ax[ax_id_rm].set_ylim((-5, 110))
            ax_rm_2nd.set_ylim((-5, 110))
            ax[ax_id_rm].set_ylabel('Percent identity [non-target species]')
            ax_rm_2nd.set_ylabel('Percent identity difference\n[non-target - target species]')
            ax[ax_id_rm].set_xlabel('Contig ID')
            ax[ax_id_rm].set_xticklabels(ax[ax_id_rm].get_xticklabels(), rotation=90)
            ax[ax_id_rm].set_title('Removed contigs >= 500 bp')
            ax[ax_id_rm].grid(which='major', axis='y')
    
    if 'lgd' in locals():
        fig.suptitle(f'Percent-identity differences of non-target vs target species\nof top Blast hits per contig in {assembly_name}', size = 14)
        plt.tight_layout()
        fig.savefig(plt_file.replace('.pdf', '_nonTargetIdentity.pdf')) # , bbox_extra_artists=(lgd, ), bbox_inches='tight')
    else:
        fig.suptitle(f'Percent-identity differences of non-target vs target species\nof top Blast hits per contig in {assembly_name}', size = 14)
        plt.tight_layout()
        fig.savefig(plt_file.replace('.pdf', '_nonTargetIdentity.pdf'))

''' MAIN '''
if __name__ == "__main__":
    
    if args.outdir[-1] != '/':
        args.outdir = args.outdir + '/'
    ## generate output folders
    subprocess.run("mkdir -p " + args.outdir, shell=True)
    subprocess.run("mkdir -p " + args.outdir + 'blast/seqs ' + args.outdir + 'blast/results ' + args.outdir + 'blast/pdfs', shell=True)
    
    input_file = os.path.expanduser(args.infasta)
    outfasta = os.path.splitext(input_file)[0].split('/')[-1] + '_cleaned.fasta' ## get filename of input fasta --> will be used for output name as well
    outfasta = args.outdir + outfasta
    ## generate filename for removed sequences
    out_rem_fasta = outfasta.replace('_cleaned', '_removed_seqs')

    ## remove short and low coverage contigs from fasta
    clean_fasta(input_file, outfasta, out_rem_fasta, min_contig_len = args.contig_len, rel_contig_cov = args.contig_cov)

    ## Note: Implemented but buggy --> Need to do the pIdentDiff properly (not just on first n lines of blast output!)
    if args.do_blast:
        ## blast the contigs 
        blast_fasta_cl_f = subset_fasta(outfasta, args.outdir + 'blast/seqs/', seq_len_subset = args.blast_len)
        blast_fasta_rm_f = subset_fasta(out_rem_fasta, args.outdir + 'blast/seqs/', seq_len_subset = args.blast_len)

        ## run blast on both subsets
        blast_res_cl = run_blast(blast_fasta_cl_f, blast_db = args.ncbi_db, threads = args.threads)
        blast_res_rm = run_blast(blast_fasta_rm_f, blast_db = args.ncbi_db, threads = args.threads)
        
        ## read spec name mapper file

        ## plot blast results
        plt_pidentity_diff(blast_res_cl, blast_res_rm, args.outdir + 'blast/pdfs/blast_results_pIdentDiff.pdf')
    else:
        print('No blasting of contigs was done')
